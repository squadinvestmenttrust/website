<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squad Investment Trust</title>
    <style>
        :root {
            --main-color: #00FF41;
            --bg-color: #000000;
            --font-family: 'Courier New', Courier, monospace;
        }

        body {
            background-color: var(--bg-color);
            color: var(--main-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 1rem;
            font-size: 16px;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            max-width: 1000px;
            margin: auto;
        }

        .header-text {
            min-height: 1.2em;
            font-size: 1.2rem;
            white-space: pre-wrap;
        }

        .content-wrapper {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 2rem;
            align-items: flex-start;
        }

        .table-container {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            font-size: 1.1rem;
        }

        .holding-item {
            margin-bottom: 1rem;
            line-height: 1.4;
        }
        .holding-item strong {
            display: inline-block;
            min-width: 60px;
        }

        .chart-container {
            flex: 1;
            min-width: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .graph-container {
            width: 100%;
        }

        svg {
            width: 100%;
            height: auto;
            stroke: var(--main-color);
            fill: var(--main-color);
            stroke-width: 2;
            font-family: var(--font-family);
        }

        .pie-chart-label {
            font-size: 8px;
            fill: var(--main-color);
            stroke: none;
            text-anchor: middle;
        }

        .graph-label {
            font-size: 12px;
            fill: var(--main-color);
            stroke: none;
            text-anchor: middle;
        }

        .graph-axis-label-y {
            text-anchor: end;
        }

        .cursor::after {
            content: 'â–ˆ';
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            from, to {
                opacity: 1;
            }
            50% {
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="loading-text" class="header-text"></div>
        <div id="tendies-text" class="header-text"></div>

        <div class="content-wrapper">
            <div id="table-container" class="table-container"></div>
            <div id="pie-chart-container" class="chart-container"></div>
        </div>

        <div id="graph-container" class="graph-container"></div>
    </div>

    <script>
        const loadingTextEl = document.getElementById('loading-text');
        const tendiesTextEl = document.getElementById('tendies-text');
        const tableContainerEl = document.getElementById('table-container');
        const pieChartContainerEl = document.getElementById('pie-chart-container');
        const graphContainerEl = document.getElementById('graph-container');

        const SPREADSHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQvIkFEd8DqGzQOSMan7QNAuwDI4fXgD1HB8PDbmnnqk5QmA0YNigbxyWuuKhoAys9VRKrbDqym2xDw/pub?output=csv';

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        async function typeText(element, text, speed = 50) {
            element.classList.add('cursor');
            let currentText = "";
            for (let i = 0; i < text.length; i++) {
                currentText += text.charAt(i);
                element.innerHTML = currentText.replace(/\n/g, '<br>');
                await sleep(speed);
            }
            element.classList.remove('cursor');
        }

        async function typeDots(element, count = 5, speed = 200) {
            element.classList.add('cursor');
            for (let i = 0; i < count; i++) {
                element.textContent += '.';
                await sleep(speed);
            }
            element.classList.remove('cursor');
        }

        async function getSheetData() {
            try {
                const response = await fetch(SPREADSHEET_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const csvText = await response.text();
                return csvText.split('\n').map(row => row.trim().split(','));
            } catch (e) {
                console.error("Error fetching or parsing spreadsheet data:", e);
                loadingTextEl.textContent = "Error: Could not load spreadsheet data.";
                return null;
            }
        }

        function drawTable(data) {
            const holdings = data.slice(2).filter(row => row[0]);
            let tableString = '';
            holdings.forEach(row => {
                const holdingName = row[0] || 'N/A';
                const value = parseFloat(row[3]).toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 });
                const profitPercent = (row[6] || '0');
                tableString += `<div class="holding-item">`;
                tableString += `<strong>Holding:</strong> ${holdingName}\n`;
                tableString += `<strong>Value:</strong> ${value}\n`;
                tableString += `<strong>Profit:</strong> ${profitPercent}%\n`;
                tableString += `</div>`;
            });
            typeText(tableContainerEl, tableString, 1);
        }

        function drawPieChart(data) {
            const holdingsData = data.slice(2)
                .filter(row => row[0] && parseFloat(row[3]) > 0)
                .map(row => ({ name: row[0], value: parseFloat(row[3]) }));

            const totalValue = holdingsData.reduce((sum, item) => sum + item.value, 0);
            if (totalValue === 0) return;

            const radius = 100;
            const cx = radius;
            const cy = radius;
            let startAngle = -90;

            let svgContent = `<svg viewBox="0 0 ${radius * 2} ${radius * 2}" preserveAspectRatio="xMidYMid meet">`;

            holdingsData.forEach(item => {
                const percentage = item.value / totalValue;
                const angle = percentage * 360;
                const endAngle = startAngle + angle;

                const start = polarToCartesian(cx, cy, radius, endAngle);
                const end = polarToCartesian(cx, cy, radius, startAngle);
                const largeArcFlag = angle > 180 ? "1" : "0";

                const d = [
                    "M", cx, cy,
                    "L", end.x, end.y,
                    "A", radius, radius, 0, largeArcFlag, 1, start.x, start.y,
                    "Z"
                ].join(" ");

                svgContent += `<path d="${d}" fill="none" stroke-width="2"></path>`;

                const labelAngle = startAngle + angle / 2;
                const labelPos = polarToCartesian(cx, cy, radius * 0.7, labelAngle);
                svgContent += `
                    <text x="${labelPos.x}" y="${labelPos.y - 6}" class="pie-chart-label">${item.name}</text>
                    <text x="${labelPos.x}" y="${labelPos.y + 8}" class="pie-chart-label">${Math.round(percentage * 100)}%</text>
                `;
                startAngle = endAngle;
            });

            svgContent += `</svg>`;
            pieChartContainerEl.innerHTML = svgContent;
        }

        function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
            const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
            return {
                x: centerX + (radius * Math.cos(angleInRadians)),
                y: centerY + (radius * Math.sin(angleInRadians))
            };
        }

        function drawLineGraph(data) {
            const graphData = data.slice(1)
                .filter(row => row[7] && row[8])
                .map(row => {
                    const [day, month, year] = row[7].split('/');
                    return {
                        date: new Date(`${year}-${month}-${day}`),
                        value: parseFloat(row[8])
                    };
                })
                .sort((a, b) => a.date - b.date);

            if (graphData.length < 2) return;

            const width = 800;
            const height = 400;
            const padding = 60;

            const maxValue = Math.max(...graphData.map(d => d.value));
            const yMax = Math.ceil(maxValue / 10000) * 10000;

            const dates = graphData.map(d => d.date);
            const startDate = new Date(Math.min(...dates));
            const endDate = new Date(Math.max(...dates));

            const xScale = (date) => {
                return padding + ((date - startDate) / (endDate - startDate)) * (width - padding * 2);
            };

            const yScale = (value) => {
                return height - padding - (value / yMax) * (height - padding * 2);
            };

            let svgContent = `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">`;

            svgContent += `<line x1="${padding}" y1="${padding}" x2="${padding}" y2="${height - padding}" stroke-width="1"></line>`;
            for (let i = 0; i <= yMax; i += 10000) {
                const y = yScale(i);
                svgContent += `<line x1="${padding - 5}" y1="${y}" x2="${width - padding}" y2="${y}" stroke-width="0.5" stroke-dasharray="4"></line>`;
                svgContent += `<text x="${padding - 10}" y="${y + 4}" class="graph-label graph-axis-label-y">$${i / 1000}K</text>`;
            }

            svgContent += `<line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke-width="1"></line>`;
            const startYear = startDate.getFullYear();
            const endYear = endDate.getFullYear();
            for (let year = startYear; year <= endYear; year++) {
                const x = xScale(new Date(`${year}-01-01`));
                svgContent += `<text x="${x}" y="${height - padding + 20}" class="graph-label">${year}</text>`;
            }

            const points = graphData.map(d => `${xScale(d.date)},${yScale(d.value)}`).join(' ');
            svgContent += `<polyline points="${points}" fill="none" stroke-width="3"></polyline>`;
            svgContent += `</svg>`;
            graphContainerEl.innerHTML = svgContent;
        }

        async function main() {
            await typeText(loadingTextEl, 'Loading', 80);
            await typeDots(loadingTextEl, 5, 250);
            await sleep(500);

            await typeText(loadingTextEl, '.....and it\'s gone', 80);
            await sleep(1000);

            const sheetData = await getSheetData();
            if (!sheetData) return;

            const jokingValue = parseFloat(sheetData[1][3]).toLocaleString('en-US', { style: 'currency', currency: 'USD' }) || '$0';
            await typeText(loadingTextEl, `Relax guy, you have ${jokingValue}`);

            const tendiesValue = parseFloat(sheetData[1][5]).toLocaleString('en-US', { style: 'currency', currency: 'USD' }) || '$0';
            await typeText(tendiesTextEl, `Total tendies to date ${tendiesValue}`);

            drawTable(sheetData);
            drawPieChart(sheetData);
            drawLineGraph(sheetData);
        }

        window.onload = main;
    </script>
</body>
</html>
