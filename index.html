<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squad Investment Trust</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --main-color: #00ff41;
            --bg-color: #000000;
        }

        html, body {
            background-color: var(--bg-color);
            color: var(--main-color);
            font-family: 'VT323', monospace;
            font-size: 18px;
            margin: 0;
            padding: 1rem;
            overflow-x: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            width: 100%;
            max-width: 1200px;
            margin: auto;
        }

        .header-text, .summary-text {
            min-height: 1.5em; /* Reserve space to prevent layout shift */
            font-size: 1.5em;
        }

        .main-content {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 2rem;
            align-items: flex-start;
        }

        .table-container {
            flex: 1;
            min-width: 300px;
        }

        #portfolio-table {
            white-space: pre;
            font-family: 'VT323', monospace;
            font-size: 1em;
            line-height: 1.2;
        }

        .pie-chart-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 300px;
            min-height: 300px;
        }

        .graph-container {
            width: 100%;
            min-height: 350px; /* Give it a minimum height */
        }
        
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Blinking cursor effect */
        .cursor::after {
            content: 'â–ˆ';
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <div id="loading-text" class="header-text cursor"></div>
        <div id="tendies-text" class="summary-text"></div>

        <div class="main-content">
            <div class="table-container">
                <pre id="portfolio-table"></pre>
            </div>
            <div class="pie-chart-container">
                <canvas id="pie-chart"></canvas>
            </div>
        </div>

        <div class="graph-container">
            <canvas id="line-graph"></canvas>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const PORTFOLIO_SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQvIkFEd8DqGzQOSMan7QNAuwDI4fXgD1HB8PDbmnnqk5QmA0YNigbxyWuuKhoAys9VRKrbDqym2xDw/pub?gid=0&single=true&output=csv';
        const HISTORICAL_SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQvIkFEd8DqGzQOSMan7QNAuwDI4fXgD1HB8PDbmnnqk5QmA0YNigbxyWuuKhoAys9VRKrbDqym2xDw/pub?gid=150645858&single=true&output=csv';

        // --- DOM ELEMENTS ---
        const loadingTextEl = document.getElementById('loading-text');
        const tendiesTextEl = document.getElementById('tendies-text');
        const tableEl = document.getElementById('portfolio-table');
        const pieCanvas = document.getElementById('pie-chart');
        const lineCanvas = document.getElementById('line-graph');

        // --- UTILITY FUNCTIONS ---

        /**
         * Pauses execution for a given duration.
         * @param {number} ms - Milliseconds to wait.
         * @returns {Promise<void>}
         */
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        /**
         * Simulates a typewriter effect for a given text element.
         * @param {HTMLElement} element - The HTML element to type into.
         * @param {string} text - The text to type.
         * @param {number} speed - The typing speed in milliseconds per character.
         */
        async function typeWriter(element, text, speed = 50) {
            element.classList.add('cursor');
            for (let i = 0; i < text.length; i++) {
                element.innerHTML += text.charAt(i);
                await sleep(speed);
            }
            element.classList.remove('cursor');
        }

        /**
         * Fetches and parses CSV data from a URL.
         * @param {string} url - The URL of the CSV file.
         * @returns {Promise<string[][]>} A promise that resolves to an array of arrays (rows and columns).
         */
        async function fetchCSV(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
                const text = await response.text();
                // Simple CSV parser: splits by newline, then by comma. Handles quoted fields.
                return text.trim().split('\n').map(row => row.split(',').map(cell => cell.trim().replace(/^"|"$/g, '')));
            } catch (error) {
                console.error('Error fetching CSV:', error);
                loadingTextEl.innerHTML = `[ERROR] Failed to fetch data from sheet.`;
                return null;
            }
        }
        
        /**
         * Formats a number into a currency string (e.g., $1,234.56).
         * @param {number} num - The number to format.
         * @returns {string}
         */
        const formatCurrency = (num) => {
            return new Intl.NumberFormat('en-AU', {
                style: 'currency',
                currency: 'AUD',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(num);
        }

        /**
         * Sets up a canvas for high-DPI rendering.
         * @param {HTMLCanvasElement} canvas - The canvas element.
         * @returns {CanvasRenderingContext2D} The 2D rendering context.
         */
        function setupCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--main-color');
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--main-color');
            ctx.font = `14px 'VT323', monospace`;
            ctx.lineWidth = 2;
            return ctx;
        }


        // --- MAIN LOGIC FUNCTIONS ---

        /**
         * Displays the initial loading animation and welcome message.
         * @param {string[][]} portfolioData - The parsed portfolio data from the CSV.
         */
        async function runIntro(portfolioData) {
            await typeWriter(loadingTextEl, 'Loading', 75);
            for (let i = 0; i < 5; i++) {
                loadingTextEl.innerHTML += '.';
                await sleep(300);
            }
            await sleep(500);
            loadingTextEl.innerHTML = '';
            await typeWriter(loadingTextEl, '.....and it\'s gone.', 75);
            await sleep(1000);
            
            const totalValue = formatCurrency(parseFloat(portfolioData[1][3]));
            loadingTextEl.innerHTML = '';
            await typeWriter(loadingTextEl, `joking, you have ${totalValue}`);

            const totalTendies = formatCurrency(parseFloat(portfolioData[1][5]));
            tendiesTextEl.classList.add('cursor');
            await typeWriter(tendiesTextEl, `Total tendies to date ${totalTendies}`);
            tendiesTextEl.classList.remove('cursor');
        }

        /**
         * Generates and displays the portfolio table.
         * @param {string[][]} portfolioData - The parsed portfolio data.
         */
        async function buildTable(portfolioData) {
            const holdings = portfolioData.slice(2).filter(row => row[0]); // Start from 3rd row, ensure holding exists
            
            const headers = ['Holding', 'Value', 'Profit', 'Profit %'];
            const cols = [
                [...holdings.map(row => row[0])],
                [...holdings.map(row => formatCurrency(parseFloat(row[3])))],
                [...holdings.map(row => formatCurrency(parseFloat(row[5])))],
                [...holdings.map(row => `${parseFloat(row[6]).toFixed(2)}%`)]
            ];

            const colWidths = headers.map((header, i) => {
                return Math.max(header.length, ...cols[i].map(cell => cell.length));
            });
            
            let tableString = '';
            const topBorder = `+${colWidths.map(w => '-'.repeat(w + 2)).join('+')}+\n`;
            const headerRow = `| ${headers.map((h, i) => h.padEnd(colWidths[i])).join(' | ')} |\n`;

            tableString += topBorder + headerRow + topBorder;

            for (let i = 0; i < holdings.length; i++) {
                const cells = [
                    cols[0][i].padEnd(colWidths[0]),
                    cols[1][i].padStart(colWidths[1]),
                    cols[2][i].padStart(colWidths[2]),
                    cols[3][i].padStart(colWidths[3])
                ];
                tableString += `| ${cells.join(' | ')} |\n`;
            }
            tableString += topBorder;

            tableEl.classList.add('cursor');
            await typeWriter(tableEl, tableString, 5);
            tableEl.classList.remove('cursor');
        }

        /**
         * Draws the pie chart on its canvas.
         * @param {string[][]} portfolioData - The parsed portfolio data.
         */
        async function drawPieChart(portfolioData) {
            const holdings = portfolioData.slice(2)
                .filter(row => row[0] && parseFloat(row[3]) > 0)
                .map(row => ({
                    label: row[0],
                    value: parseFloat(row[3])
                }));
            
            const totalValue = holdings.reduce((sum, h) => sum + h.value, 0);
            if (totalValue === 0) return;

            const ctx = setupCanvas(pieCanvas);
            const centerX = pieCanvas.clientWidth / 2;
            const centerY = pieCanvas.clientHeight / 2;
            const radius = Math.min(centerX, centerY) * 0.7;

            let startAngle = -0.5 * Math.PI; // Start at the top

            // Draw the main circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.stroke();
            await sleep(200);

            for (const holding of holdings) {
                const sliceAngle = (holding.value / totalValue) * 2 * Math.PI;
                const endAngle = startAngle + sliceAngle;

                // Draw dividing line
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + radius * Math.cos(startAngle), centerY + radius * Math.sin(startAngle));
                ctx.stroke();
                await sleep(100);

                // Draw label
                const labelAngle = startAngle + sliceAngle / 2;
                const percentage = (holding.value / totalValue * 100).toFixed(0);
                const labelText = `${holding.label} ${percentage}%`;
                const labelX = centerX + (radius * 0.6) * Math.cos(labelAngle);
                const labelY = centerY + (radius * 0.6) * Math.sin(labelAngle);
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(labelText, labelX, labelY);
                await sleep(50);
                
                startAngle = endAngle;
            }
        }
        
        /**
         * Draws the line graph on its canvas.
         * @param {string[][]} historicalData - The parsed historical data.
         */
        async function drawLineGraph(historicalData) {
            const data = historicalData.slice(1) // Skip header
                .map(row => {
                    const dateParts = row[7].split('/'); // DD/MM/YYYY
                    return {
                        date: new Date(dateParts[2], dateParts[1] - 1, dateParts[0]),
                        value: parseFloat(row[8])
                    };
                })
                .filter(d => !isNaN(d.date) && !isNaN(d.value))
                .sort((a, b) => a.date - b.date);

            if (data.length < 2) return;

            const ctx = setupCanvas(lineCanvas);
            const padding = { top: 20, bottom: 40, left: 60, right: 20 };
            const graphWidth = lineCanvas.clientWidth - padding.left - padding.right;
            const graphHeight = lineCanvas.clientHeight - padding.top - padding.bottom;

            const maxValue = Math.max(...data.map(d => d.value));
            const yMax = Math.ceil(maxValue / 10000) * 10000;
            const minDate = data[0].date;
            const maxDate = data[data.length - 1].date;

            // Draw axes
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, padding.top + graphHeight);
            ctx.lineTo(padding.left + graphWidth, padding.top + graphHeight);
            ctx.stroke();

            // Draw Y-axis labels and grid lines
            const yLabelCount = yMax / 10000;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let i = 0; i <= yLabelCount; i++) {
                const value = i * 10000;
                const y = padding.top + graphHeight - (value / yMax) * graphHeight;
                ctx.fillText(`$${i}0K`, padding.left - 10, y);
                
                ctx.beginPath();
                ctx.moveTo(padding.left - 5, y);
                ctx.lineTo(padding.left + graphWidth, y);
                ctx.strokeStyle = 'rgba(0, 255, 65, 0.2)';
                ctx.stroke();
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--main-color');
            }
            
            // Draw X-axis labels (Years)
            const years = [...new Set(data.map(d => d.date.getFullYear()))];
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (const year of years) {
                const yearDate = new Date(year, 0, 1);
                const x = padding.left + ((yearDate - minDate) / (maxDate - minDate)) * graphWidth;
                if(x > padding.left -5 && x < padding.left + graphWidth + 5) {
                    ctx.fillText(year, x, padding.top + graphHeight + 10);
                }
            }

            // Draw the line
            ctx.beginPath();
            const getCoords = (d) => ({
                x: padding.left + ((d.date - minDate) / (maxDate - minDate)) * graphWidth,
                y: padding.top + graphHeight - (d.value / yMax) * graphHeight
            });
            
            let firstPoint = getCoords(data[0]);
            ctx.moveTo(firstPoint.x, firstPoint.y);
            
            for(let i = 1; i < data.length; i++) {
                const point = getCoords(data[i]);
                ctx.lineTo(point.x, point.y);
                ctx.stroke(); // To animate segment by segment
                ctx.beginPath(); // Start new path for next segment
                ctx.moveTo(point.x, point.y);
                await sleep(5);
            }
        }


        // --- MAIN EXECUTION ---
        document.addEventListener('DOMContentLoaded', async () => {
            // Fetch data first
            const [portfolioData, historicalData] = await Promise.all([
                fetchCSV(PORTFOLIO_SHEET_URL),
                fetchCSV(HISTORICAL_SHEET_URL)
            ]);

            if (!portfolioData || !historicalData) {
                loadingTextEl.innerHTML = '[FATAL ERROR] Cannot render page without data.';
                return;
            }
            
            // Run animations sequentially
            await runIntro(portfolioData);
            
            // Run table and charts concurrently
            Promise.all([
                buildTable(portfolioData),
                drawPieChart(portfolioData)
            ]);
            
            await drawLineGraph(historicalData);
        });
    </script>
</body>
</html>
