<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Squad Investment Trust</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
    }
    #container {
      max-width: 800px;
      width: 100%;
      padding: 40px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 20px;
      white-space: pre;
    }
    .section {
      visibility: hidden;
    }
    #message {
      font-size: 24px;
    }
    table.ascii {
      font-family: inherit;
      font-size: inherit;
      line-height: 1.2;
    }
    canvas {
      background: #000;
      width: 100%;
      height: auto;
      display: block;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
</head>
<body>
  <div id="container">
    <div id="message" class="section">Loading</div>
    <div id="table" class="section"></div>
    <div id="tendies" class="section"></div>
    <div id="pieContainer" class="section">
      <canvas id="pieChart"></canvas>
    </div>
    <div id="chartContainer" class="section">
      <canvas id="performanceChart"></canvas>
    </div>
  </div>

  <script>
    const msgEl = document.getElementById('message');
    const tableEl = document.getElementById('table');
    const tendiesEl = document.getElementById('tendies');
    const pieSection = document.getElementById('pieContainer');
    const chartSection = document.getElementById('chartContainer');
    const pieCtx = document.getElementById('pieChart').getContext('2d');
    const perfCtx = document.getElementById('performanceChart').getContext('2d');

    function delay(ms) {
      return new Promise(r => setTimeout(r, ms));
    }

    async function showLoadingDots() {
      for (let i = 0; i < 5; i++) {
        msgEl.textContent += '.';
        await delay(300);
      }
    }

    async function typeText(el, text, speed = 2) {
      el.textContent = '';
      for (let ch of text) {
        el.textContent += ch;
        await delay(speed);
      }
    }

    async function fetchSheetData() {
      const url = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQvIkFEd8DqGzQOSMan7QNAuwDI4fXgD1HB8PDbmnnqk5QmA0YNigbxyWuuKhoAys9VRKrbDqym2xDw/pub?output=csv';
      const res = await fetch(url);
      if (!res.ok) throw new Error('Network error');
      const text = await res.text();
      return text.split('\n').map(r => r.split(','));
    }

    function parseData(rows) {
      // header row at index 0, totals at 1
      const totalValue = parseFloat(rows[1][3].replace(/[$,]/g,'')).toLocaleString();
      const totalTendies = parseFloat(rows[1][5].replace(/[$,]/g,'')).toLocaleString();

      const holdings = [], dates = [], values = [];
      for (let i = 2; i < rows.length; i++) {
        const [name,, ,valueRaw,,profitRaw,,,date,valRaw] = rows[i];
        const valueNum = parseFloat((valueRaw||'').replace(/[$,]/g,''));
        const profitNum = parseFloat((profitRaw||'').replace(/[$,]/g,''));
        if (name && !isNaN(valueNum) && !isNaN(profitNum)) {
          holdings.push({ name: name.trim(), valueNum, value: valueNum.toLocaleString(), profit: profitNum.toLocaleString() });
        }
        const val = parseFloat((valRaw||'').replace(/[$,]/g,''));
        if (date && !isNaN(val)) {
          dates.push(date.trim());
          values.push(val);
        }
      }
      return { totalValue, totalTendies, holdings, dates, values };
    }

    function buildASCIITable(holdings) {
      const c1 = Math.max(...holdings.map(h=>h.name.length),7);
      const c2 = Math.max(...holdings.map(h=>h.value.length),5);
      const c3 = Math.max(...holdings.map(h=>h.profit.length),6);
      const line = '+'+'-'.repeat(c1+2)+'+'+'-'.repeat(c2+2)+'+'+'-'.repeat(c3+2)+'+\n';
      let tbl = line
        + `| ${'Holding'.padEnd(c1)} | ${'Value'.padStart(c2)} | ${'Profit'.padStart(c3)} |\n`
        + line;
      holdings.forEach(h => {
        tbl += `| ${h.name.padEnd(c1)} | ${h.value.padStart(c2)} | ${h.profit.padStart(c3)} |\n`;
      });
      return tbl + line;
    }

    function showSection(el) {
      el.style.visibility = 'visible';
    }

    function renderPie(holdings) {
      const data = holdings.map(h => h.valueNum);
      const total = data.reduce((a,b)=>a+b,0);
      const labels = holdings.map(h => `${h.name} ${Math.round(h.valueNum/total*100)}%`);
      new Chart(pieCtx, {
        type: 'pie',
        data: { labels, datasets: [{ data, backgroundColor: data.map(()=> 'transparent'), borderColor: '#0f0', borderWidth: 2 }] },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            datalabels: {
              color: '#0f0',
              formatter: (_,ctx) => ctx.chart.data.labels[ctx.dataIndex],
              font: { size: 14 }
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    function renderLine(dates, values) {
      // clear canvas
      perfCtx.clearRect(0,0,perfCtx.canvas.width, perfCtx.canvas.height);
      const pad=50, w=perfCtx.canvas.width-2*pad, h=perfCtx.canvas.height-2*pad;
      const ts = dates.map(d => {
        const [dStr,mStr,yStr] = d.split('/');
        return new Date(`${yStr}-${mStr}-${dStr}`).getTime();
      });
      const minT = Math.min(...ts), maxT = Math.max(...ts);
      const minV = Math.min(...values), maxV = Math.max(...values);
      const step = 10000;

      perfCtx.strokeStyle = '#004400';
      perfCtx.fillStyle = '#0f0';
      perfCtx.font = '14px Courier New';
      perfCtx.textAlign = 'right';

      for (let v=Math.ceil(minV/step)*step; v<=maxV; v+=step) {
        const y = pad + h - (v-minV)/(maxV-minV)*h;
        perfCtx.beginPath();
        perfCtx.moveTo(pad,y);
        perfCtx.lineTo(pad+w,y);
        perfCtx.stroke();
        perfCtx.fillText(`$${v/1000}K`, pad-5, y+5);
      }

      perfCtx.textAlign = 'center';
      const years = {};
      ts.forEach((t,i) => {
        const yr = new Date(t).getFullYear();
        if (!years[yr]) {
          const x = pad + (t-minT)/(maxT-minT)*w;
          perfCtx.fillText(yr, x, perfCtx.canvas.height - 10);
          years[yr] = true;
        }
      });

      perfCtx.strokeStyle = '#0f0';
      perfCtx.lineWidth = 2;
      perfCtx.beginPath();
      values.forEach((v,i) => {
        const x = pad + (ts[i]-minT)/(maxT-minT)*w;
        const y = pad + h - (v-minV)/(maxV-minV)*h;
        i ? perfCtx.lineTo(x,y) : perfCtx.moveTo(x,y);
      });
      perfCtx.stroke();
    }

    async function run() {
      await showLoadingDots();
      await delay(500);
      msgEl.textContent = ".....and it's gone";
      await delay(800);

      try {
        const raw = await fetchSheetData();
        const { totalValue, totalTendies, holdings, dates, values } = parseData(raw);

        msgEl.textContent = `joking, you have $${totalValue}`;
        showSection(msgEl);

        const ascii = buildASCIITable(holdings);
        tableEl.classList.add('ascii');
        await typeText(tableEl, ascii);
        showSection(tableEl);

        tendiesEl.textContent = `Total tendies to date $${totalTendies}`;
        showSection(tendiesEl);

        renderPie(holdings);
        showSection(pieSection);

        renderLine(dates, values);
        showSection(chartSection);

      } catch (err) {
        msgEl.textContent = 'Error loading data';
        showSection(msgEl);
        console.error(err);
      }
    }

    run();
  </script>
</body>
</html>
